/*
Read key from the Maerklin IR control 00748
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Return the number of the key
- Return the switch position on the backside (Channel)
- Detect different key press times
   - Short
   - Long
   - Double ?
  The key press time is returned in a second variable
- Status:
   - IR_NO_KEY
   - IR_KEY_PRESSED
   - IR_KEY_RELEASED
   - IR_KEY_HOLD
- While a key is pressed the function

- IR receiver details
   - If a key is pressed the the IR receiver returns a number every MAX_KEY_PERIOD ms
   - If the key is released and pressed a second time a second number is received.
     This could be used to detect if a key pressed several times within a short time.
   - To detect if a key is released the program has to wait for MAX_KEY_PERIOD ms after
     the last detected key.


- Return value bitmask
    76543210    k = key 0..7
    phccrkkk    c = channel 0..3
                p = key pressed
                h = key hold
                r = key released

  New mask for additional numerical keys for switches...   27.09.17
    76543210 76543210
    phr---cc kkkkkkkk   k = key 0..7 IR, 8-.. Other
                        c = channel 0..3
                        p = key pressed
                        h = key hold
                        r = key released

- Possible use cases:
- Menu: Reaction on IR_KEY_PRESSED
- Scroll on List: IR_KEY_PRESSED and IR_KEY_HOLD:
- Speed controll: IR_KEY_PRESSED and IR_KEY_HOLD


           ____
 Short ___|    |______________  If the key is pressed for a short time (<= KEY_SHORT_TIME) the function
          t0     t1             returns two times a result:
                                  t0:    IR_KEY_PRESSED
                                  t1:    IR_KEY_RELEASED is returned KEY_PERIOD after the key was released
           ____________
 Long  ___|            |______  If the key is pressed longer than KEY_SHORT_TIME the function returns
          t0      t1 t2 t3      the following results:
                                  t0:     IR_KEY_PRESSED
                                  t1, t2: IR_KEY_HOLD
                                  t3:     IR_KEY_RELEASED
           _   _   _
 Multi ___| |_| |_| |_________   If the key is pressed several times for a short time to step to a menu
          t0  t1  t2  t3         or to change the speed the IR_KEY_PRESSED is returned every time
                                 the key is pressed:
                                   t0:    IR_KEY_PRESSED
                                   t1:    IR_KEY_PRESSED
                                   t2:    IR_KEY_PRESSED
                                   t3:    IR_KEY_RELEASED

ToDo:
- What happens if the function is not called while a key is pressed ?
  Problem if a key is pressed 3 times it returns the same key code at
  the first and third time. If the second event is not captured because
  the function was not called it looks like the key was hold during the
  whole time.
- Period KEY_PERIOD 113 ms
- Is the alternating key code generated by the transmitter or receiver ?
  => transmitter


*/

#include "IR_Key_Input.h"
#include "Dprintf.h"

#if defined(__AVR_ATmega2560__)
    // Generate a warning if unneccesary decoders are enabled
    #if DECODE_RC6  || DECODE_SONY || DECODE_PANASONIC || DECODE_JVC || DECODE_SAMSUNG || DECODE_WHYNTER || DECODE_AIWA_RC_T501 || DECODE_LG || DECODE_SANYO || DECODE_MITSUBISHI || DECODE_DISH || DECODE_SHARP || DECODE_DENON || DECODE_PRONTO || DECODE_LEGO_PF
      #warning "Disable all decode protocols except DECODE_RC5 in IRremote.h to save 2824 bytes FLASH !"
    #endif

    #if BLINKLED != 17
      #error Special IRremote library which is patched by hardi must be used. It defines BLINKLED to 17
    /*
      Changes in boarddefs.h:
         // 27.09.17: Hardi
         #define BLINKLED        17
         #define BLINKLED_ON()   (PORTC |= B00001000)
         #define BLINKLED_OFF()  (PORTC &= B11110111)

         #if defined(BLINKLED) // 26.09.17:
         // defined in the program which is including the library prior to the #include

         #elif defined(CORE_LED0_PIN)
    */
    #endif
#endif // __AVR_ATmega2560__

//-------------------------------------------
IR_Key_Input_c::IR_Key_Input_c(uint8_t PinNr) // Constructor
//-------------------------------------------
{
  this->PinNr = PinNr;
  irrecv      = NULL;
  LastKey     = 0;
  LastCode    = 0xFFFFFFFF;
  LastTime    = 0;
  FirstTime   = 0;
}

//-----------------------------
void IR_Key_Input_c::Init(void)
//-----------------------------
// For some reasons the following can't called in the constructor.
// It must be called after Serial.begin(19200) in the setup()
// If it's called before strange IR codes will be received
{
  if (!irrecv)
     {
     irrecv = new IRrecv(PinNr);
     irrecv->enableIRIn(); // Start the IR receiver
     #if defined(__AVR_ATmega2560__)
        irrecv->blink13(1);                    // ToDo: Define also for the ESP
     #endif
     #if 0
       #if defined(IR_USE_TIMER1)
         Dprintf("IR_USE_TIMER1\n");
       #elif defined(IR_USE_TIMER2)
         Dprintf("IR_USE_TIMER2\n");
       #elif defined(IR_USE_TIMER3)
         Dprintf("IR_USE_TIMER3\n");
       #elif defined(IR_USE_TIMER4)
         Dprintf("IR_USE_TIMER4_HS\n");
       #elif defined(IR_USE_TIMER3)
         Dprintf("IR_USE_TIMER4_HS\n\n");
       #elif defined(IR_USE_TIMER5)
         Dprintf("IR_USE_TIMER5\n");
       #endif
     #endif
     }
}

//---------------------------------------
void IR_Key_Input_c::Test_IR_Period(void) // Debug
//---------------------------------------
// Measure the period of the IR data if a key on the IR control is pushed permanent
// Result: Period = 113 ms
{
#ifdef PRINT_DEBUG_MESSAGES
  Init();
  uint32_t Start = 0;
  while (1)
     {
     decode_results results;
     if (irrecv->decode(&results))
        {
        uint32_t Duration = millis() - Start;
        Dprintf("IR %lX %li\n", results.value, Duration);
        irrecv->resume(); // Receive the next value
        Start = millis();
        }
     else delay(100); // Otherwise the watchdog bites
     }
#endif
}

//------------------------------------------------------
IR_Key_t IR_Key_Input_c::Read_IR_Key(uint16_t &Duration)
//------------------------------------------------------
// Attention: The key code 0xFFFFFFFF is used to indicate no key
{
  Init();
  IR_Key_t key = IR_NO_KEY;
  decode_results results;
  uint32_t t = millis();
  if (irrecv->decode(&results))
       {
       // Dprintf("Key %08X ", (uint32_t)results.value); // Debug
       irrecv->resume(); // Receive the next value
       uint8_t KnownKey = 1;
       switch ((uint32_t)results.value)
          {
          // Lok Stop / Direction
          case 0x60D: case 0xE0D:           key = IR_CHANNEL_0 + IR_KEY_M_STOP;     break;
          case 0x64D: case 0xE4D:           key = IR_CHANNEL_1 + IR_KEY_M_STOP;     break;
          case 0x6CD: case 0xECD:           key = IR_CHANNEL_2 + IR_KEY_M_STOP;     break;
          case 0x70D: case 0xF0D:           key = IR_CHANNEL_3 + IR_KEY_M_STOP;     break;
    #if defined(__AVR_ATmega2560__)
          // Lok Functions Ch0
          case 0x06CE2B0C: case 0x4F3749E1: key = IR_CHANNEL_0 + IR_KEY_M_LIGHT;    break;
          case 0x03CE2655: case 0x52374E98: key = IR_CHANNEL_0 + IR_KEY_M_F1;       break;
          case 0x2C7541E5: case 0xFF586BFC: key = IR_CHANNEL_0 + IR_KEY_M_F2;       break;
          case 0x90B9D196: case 0xC54BA357: key = IR_CHANNEL_0 + IR_KEY_M_F3;       break;
          case 0x15910C2B: case 0x163CA1BA: key = IR_CHANNEL_0 + IR_KEY_M_F4;       break;
          // Lok Functions Ch1
          case 0x08CB39EB: case 0xEE2DF3BA: key = IR_CHANNEL_1 + IR_KEY_M_LIGHT;    break;
          case 0x07CB3856: case 0xEF2DF54F: key = IR_CHANNEL_1 + IR_KEY_M_F1;       break;
          case 0x0CB88732: case 0x1C76D2AF: key = IR_CHANNEL_1 + IR_KEY_M_F2;       break;
          case 0x7A7A608D: case 0x7C7ECD18: key = IR_CHANNEL_1 + IR_KEY_M_F3;       break;
          case 0x19296A5:  case 0x279CC338: key = IR_CHANNEL_1 + IR_KEY_M_F4;       break;
          // Lok Functions Ch2
          case 0x098A2054: case 0xD87A0659: key = IR_CHANNEL_2 + IR_KEY_M_LIGHT;    break;
          case 0x068A1B9D: case 0xDB7A0B10: key = IR_CHANNEL_2 + IR_KEY_M_F1;       break;
          case 0x43E73E04: case 0xC7F7DB9D: key = IR_CHANNEL_2 + IR_KEY_M_F2;       break;
          case 0x4E8E5FCF: case 0x9375C6DE: key = IR_CHANNEL_2 + IR_KEY_M_F3;       break;
          case 0x5ACB73C2: case 0xB113A5E3: key = IR_CHANNEL_2 + IR_KEY_M_F4;       break;
          // Lok Functions Ch3
          case 0xCFAA45D8: case 0xD65BF5ED: key = IR_CHANNEL_3 + IR_KEY_M_LIGHT;    break;
          case 0xCCAA4121: case 0xD95BFAA4: key = IR_CHANNEL_3 + IR_KEY_M_F1;       break;
          case 0xBBD55EE8: case 0xBFA79411: key = IR_CHANNEL_3 + IR_KEY_M_F2;       break;
          case 0x4C704F63: case 0x5995EC62: key = IR_CHANNEL_3 + IR_KEY_M_F3;       break;
          case 0xA8C35E57: case 0xD2B994A6: key = IR_CHANNEL_3 + IR_KEY_M_F4;       break;
    #else // ESP8266 library
          // Lok Functions Ch0
          case 0x1E10: case 0x1610:         key = IR_CHANNEL_0 + IR_KEY_M_LIGHT;    break;
          case 0x1E11: case 0x1611:         key = IR_CHANNEL_0 + IR_KEY_M_F1;       break;
          case 0x1E12: case 0x1612:         key = IR_CHANNEL_0 + IR_KEY_M_F2;       break;
          case 0x1E13: case 0x1613:         key = IR_CHANNEL_0 + IR_KEY_M_F3;       break;
          case 0x1E14: case 0x1614:         key = IR_CHANNEL_0 + IR_KEY_M_F4;       break;
          // Lok Functions Ch1
          case 0x1E50: case 0x1650:         key = IR_CHANNEL_1 + IR_KEY_M_LIGHT;    break;
          case 0x1E51: case 0x1651:         key = IR_CHANNEL_1 + IR_KEY_M_F1;       break;
          case 0x1E52: case 0x1652:         key = IR_CHANNEL_1 + IR_KEY_M_F2;       break;
          case 0x1E53: case 0x1653:         key = IR_CHANNEL_1 + IR_KEY_M_F3;       break;
          case 0x1E54: case 0x1654:         key = IR_CHANNEL_1 + IR_KEY_M_F4;       break;
          // Lok Functions Ch2
          case 0x1ED0: case 0x16D0:         key = IR_CHANNEL_2 + IR_KEY_M_LIGHT;    break;
          case 0x1ED1: case 0x16D1:         key = IR_CHANNEL_2 + IR_KEY_M_F1;       break;
          case 0x1ED2: case 0x16D2:         key = IR_CHANNEL_2 + IR_KEY_M_F2;       break;
          case 0x1ED3: case 0x16D3:         key = IR_CHANNEL_2 + IR_KEY_M_F3;       break;
          case 0x1ED4: case 0x16D4:         key = IR_CHANNEL_2 + IR_KEY_M_F4;       break;
          // Lok Functions Ch3
          case 0x1F10: case 0x1710:         key = IR_CHANNEL_3 + IR_KEY_M_LIGHT;    break;
          case 0x1F11: case 0x1711:         key = IR_CHANNEL_3 + IR_KEY_M_F1;       break;
          case 0x1F12: case 0x1712:         key = IR_CHANNEL_3 + IR_KEY_M_F2;       break;
          case 0x1F13: case 0x1713:         key = IR_CHANNEL_3 + IR_KEY_M_F3;       break;
          case 0x1F14: case 0x1714:         key = IR_CHANNEL_3 + IR_KEY_M_F4;       break;
     #endif
          // Speed keys
          case 0x611: case 0xE11:           key = IR_CHANNEL_0 + IR_KEY_M_MINUS;    break;
          case 0x651: case 0xE51:           key = IR_CHANNEL_1 + IR_KEY_M_MINUS;    break;
          case 0x6D1: case 0xED1:           key = IR_CHANNEL_2 + IR_KEY_M_MINUS;    break;
          case 0x711: case 0xF11:           key = IR_CHANNEL_3 + IR_KEY_M_MINUS;    break;
          case 0x610: case 0xE10:           key = IR_CHANNEL_0 + IR_KEY_M_PLUS;     break;
          case 0x650: case 0xE50:           key = IR_CHANNEL_1 + IR_KEY_M_PLUS;     break;
          case 0x6D0: case 0xED0:           key = IR_CHANNEL_2 + IR_KEY_M_PLUS;     break;
          case 0x710: case 0xF10:           key = IR_CHANNEL_3 + IR_KEY_M_PLUS;     break;
#ifdef GRUNDIG // RC-GD1 / RC-YC1
          case 0x00:  case 0x800:           key = IR_CHANNEL_15+ IR_KEY_G_NR0;      break;
          case 0x01:  case 0x801:           key = IR_CHANNEL_15+ IR_KEY_G_NR1;      break;
          case 0x02:  case 0x802:           key = IR_CHANNEL_15+ IR_KEY_G_NR2;      break;
          case 0x03:  case 0x803:           key = IR_CHANNEL_15+ IR_KEY_G_NR3;      break;
          case 0x04:  case 0x804:           key = IR_CHANNEL_15+ IR_KEY_G_NR4;      break;
          case 0x05:  case 0x805:           key = IR_CHANNEL_15+ IR_KEY_G_NR5;      break;
          case 0x06:  case 0x806:           key = IR_CHANNEL_15+ IR_KEY_G_NR6;      break;
          case 0x07:  case 0x807:           key = IR_CHANNEL_15+ IR_KEY_G_NR7;      break;
          case 0x08:  case 0x808:           key = IR_CHANNEL_15+ IR_KEY_G_NR8;      break;
          case 0x09:  case 0x809:           key = IR_CHANNEL_15+ IR_KEY_G_NR9;      break;
          case 0x0C:  case 0x80C:           key = IR_CHANNEL_15+ IR_KEY_G_POWER;    break;
          case 0x0D:  case 0x80D:           key = IR_CHANNEL_15+ IR_KEY_G_MUTE;     break;
          case 0x10:  case 0x810:           key = IR_CHANNEL_15+ IR_KEY_G_V_PLUS;   break;
          case 0x11:  case 0x811:           key = IR_CHANNEL_15+ IR_KEY_G_V_MINUS;  break;
          case 0x12:  case 0x812:           key = IR_CHANNEL_15+ IR_KEY_G_RIGHT;    break;
          case 0x13:  case 0x813:           key = IR_CHANNEL_15+ IR_KEY_G_LEFT;     break;
          case 0x16:  case 0x816:           key = IR_CHANNEL_15+ IR_KEY_G_UP;       break;
          case 0x17:  case 0x817:           key = IR_CHANNEL_15+ IR_KEY_G_DOWN;     break;
          case 0x20:  case 0x820:           key = IR_CHANNEL_15+ IR_KEY_G_PR_PLUS;  break;
          case 0x21:  case 0x821:           key = IR_CHANNEL_15+ IR_KEY_G_PR_MINUS; break;
          case 0x35:  case 0x835:           key = IR_CHANNEL_15+ IR_KEY_G_OK;       break;
          case 0x36:  case 0x836:           key = IR_CHANNEL_15+ IR_KEY_G_GREEN;    break;
          case 0x37:  case 0x837:           key = IR_CHANNEL_15+ IR_KEY_G_RED;      break;
          case 0x23:  case 0x823:           key = IR_CHANNEL_15+ IR_KEY_G_16_9;     break;
          case 0x22:  case 0x822:           key = IR_CHANNEL_15+ IR_KEY_G_REPEAT;   break;
          case 0x38:  case 0x838:           key = IR_CHANNEL_15+ IR_KEY_G_A_B;      break;
          case 0x25:  case 0x825:           key = IR_CHANNEL_15+ IR_KEY_G_EPG;      break;
          case 0x2D:  case 0x82D:           key = IR_CHANNEL_15+ IR_KEY_G_FIND;     break;
          case 0x19:  case 0x819:           key = IR_CHANNEL_15+ IR_KEY_G_M;        break;
          case 0x27:  case 0x827:           key = IR_CHANNEL_15+ IR_KEY_G_BACK;     break;
          case 0x2A:  case 0x82A:           key = IR_CHANNEL_15+ IR_KEY_G_i;        break;
          case 0x32:  case 0x832:           key = IR_CHANNEL_15+ IR_KEY_G_YELLOW;   break;
          case 0x34:  case 0x834:           key = IR_CHANNEL_15+ IR_KEY_G_BLUE;     break;
          case 0x3C:  case 0x83C:           key = IR_CHANNEL_15+ IR_KEY_G_TXT;      break;
          case 0x29:  case 0x829:           key = IR_CHANNEL_15+ IR_KEY_G_R;        break;
          case 0x30:  case 0x830:           key = IR_CHANNEL_15+ IR_KEY_G_BOX;      break;
          case 0x24:  case 0x824:           key = IR_CHANNEL_15+ IR_KEY_G_SPEAKER;  break;


#endif
#if 0 // "X96 Mini Android-TV-Box" remote control from Amazon: https://www.amazon.de/gp/product/B0797X28YS
      // Reagiert nicht besonders gut
      // #define DECODE_NEC in "IRremote_Maerklin.h" to read the remote control
          case 0x807F728D:                  key = IR_CHANNEL_15+ IR_KEY_NR1;      break;
          case 0x807FB04F:                  key = IR_CHANNEL_15+ IR_KEY_NR2;      break;
          case 0x807F30CF:                  key = IR_CHANNEL_15+ IR_KEY_NR3;      break;
          case 0x807F52AD:                  key = IR_CHANNEL_15+ IR_KEY_NR4;      break;
          case 0x807F906F:                  key = IR_CHANNEL_15+ IR_KEY_NR5;      break;
          case 0x807F10EF:                  key = IR_CHANNEL_15+ IR_KEY_NR6;      break;
          case 0x807F629D:                  key = IR_CHANNEL_15+ IR_KEY_NR7;      break;
          case 0x807FA05F:                  key = IR_CHANNEL_15+ IR_KEY_NR8;      break;
          case 0x807F20DF:                  key = IR_CHANNEL_15+ IR_KEY_NR9;      break;
          case 0x807F807F:                  key = IR_CHANNEL_15+ IR_KEY_NR0;      break;
#endif
          default: KnownKey = 0;
                   if (results.decode_type != UNKNOWN)
                      Dprintf("Unknown Key %08lX\n", (uint32_t)results.value);
          } // end switch
       if (KnownKey) // A known key has been detected
          {
          if (LastCode == results.value) // Same key like before
               {
               if (FirstTime > 0 && t - FirstTime > IR_KEY_SHORT_TIME) // FirstTime is set to 0 to clear pending keystrokes
                    key |= IR_KEY_HOLD;
               else key =  IR_NO_KEY;   // Don't send "hold" keys until IR_KEY_SHORT_TIME is elapsed
               }
          else key |= IR_KEY_PRESSED;

          if (LastCode == 0xFFFFFFFF)
               LastTime = FirstTime = t;
          else LastTime = millis();

          if (key != IR_NO_KEY)
             {
             Duration = t - FirstTime;
             LastCode = results.value;

             LastKey  = key;
             }
          }
       }
  else { // No key received
       if (LastCode!=0xFFFFFFFF)
          {
          if (t - LastTime > IR_KEY_RCV_PERIOD) // key has been released
             {
             if (FirstTime != 0) // FirstTime is set to 0 to clear pending key stokes
                key = (LastKey & IR_CHANNEL_AND_KEY_MASK) | IR_KEY_RELEASED;
             Duration = t - FirstTime;
             LastCode = 0xFFFFFFFF;
             }
          }
       } // end if (irrecv->decode(&results))
  return key;
}

//------------------------------
void IR_Key_Input_c::Clear(void)
//------------------------------
// Stop generating key messages until the current key is released.
// IR_KEY_HOLD and IR_KEY_RELEASED is
// not sended until the next key is pressed.
// Call this function after a long key press is detected
// to switch into an other menu.
// It could also be called to remove the IR_KEY_RELEASED
// messages at the end of the menu.
{
  FirstTime = 0; // FirstTime is set to 0 to clear pending keystrokes
}

/*
 ToDo:
 - Manchmal kommt beim loslassen die Taste 0x80 = Ch 0, Key 0
 - clear Funktion
*/

//--------------------------
char Get_Status(uint8_t key)  // Debug
//--------------------------
{
  char Status;
  switch (key & IR_STATUS_MASK)
    {
    case IR_KEY_PRESSED:  Status = 'v'; break;
    case IR_KEY_RELEASED: Status = '^'; break;
    case IR_KEY_HOLD:     Status = '='; break;
    default:                     Status = '?';
    }
  return Status;
}

//--------------------------------
void IR_Key_Input_c::IR_Test(void) // Debug
//--------------------------------
{
  Dprintf("IR_Test\n");
  //Test_IR_Period();

  while(1)
    {
    uint16_t Duration = 0;
    IR_Key_t key = Read_IR_Key(Duration);
    if (key != IR_NO_KEY)
       {
       Dprintf("%02X: Ch %i, KeyNr %i, %c Duration %i\n",key, IR_CHANNEL(key), IR_KEY(key), Get_Status(key), Duration);
       if (key & IR_KEY_RELEASED) Dprintf("\n");

       // Sub menu test
       if (IR_KEY(key) == IR_KEY_M_LIGHT && (Duration > 2000 || IR_KEY(key) == IR_KEY_M_F1))                      // 07.01.22:  Added ()
          {
          Clear();
          uint8_t SubNr = 0, End = 0;
          while (!End)
            {
            //Dprintf("Submenu %3i %c %02X\n",SubNr, Get_Status(key), key);
            Dprintf("Submenu %3i %02X: Ch %i, KeyNr %i, %c Duration %i\n",SubNr, key, IR_CHANNEL(key), IR_KEY(key), Get_Status(key), Duration);
            if (key & IR_KEY_RELEASED) Dprintf("\n");
            while ((key = Read_IR_Key(Duration)) == IR_NO_KEY)
               ; // Wait until a key is pressed

            switch (key & IR_ANY_KEY_PRESS_OR_HOLD)
               {
               case IR_KEY_M_PLUS  + IR_KEY_PRESSED: case IR_KEY_M_PLUS  + IR_KEY_HOLD: SubNr++;  break;
               case IR_KEY_M_MINUS + IR_KEY_PRESSED: case IR_KEY_M_MINUS + IR_KEY_HOLD: SubNr--;  break;
               case IR_KEY_M_LIGHT + IR_KEY_HOLD:    Dprintf("Key Light holded\n");               break; // If Clear() is not called we get this message
               case IR_KEY_M_STOP  + IR_KEY_PRESSED: Clear(); Dprintf("EndSubmenu\n"); End = 1;   break;
               }
            }
          }
       }
    else delay(100); // Otherwise the watchdog bites
    }
}
